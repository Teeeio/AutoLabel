export const SEARCH_CSS = `
      html, body {        height: 100% !important;        width: 100vw !important;        max-width: 100vw !important;        overflow-x: hidden !important;        box-sizing: border-box !important;      }      body { overflow: hidden !important; background: #ffffff !important; }      *::-webkit-scrollbar {        width: 8px !important;      }      *::-webkit-scrollbar-track {        background: transparent !important;      }      *::-webkit-scrollbar-thumb {        background: rgba(15, 23, 42, 0.28) !important;        border-radius: 999px !important;        border: 2px solid transparent !important;        background-clip: padding-box !important;      }      *::-webkit-scrollbar-thumb:hover {        background: rgba(15, 23, 42, 0.45) !important;      }      *::-webkit-scrollbar-corner {        background: transparent !important;      }      #biliMainHeader,      .bili-header,      .bili-header-m,      .international-header,      .bili-footer,      .search-header,      .search-footer,      .search-sidebar,      .search-page-right,      .search-right,      .search-tag,      .recommend-wrapper,      .nav-search-box {        display: none !important;      }      .search-page,      .search-content,      .search-container,      .search-wrap {        padding: 0 12px !important;        margin: 0 !important;      }      .search-page .video-list,      .search-all-list {        margin-top: 12px !important;      }      .rdg-search-loading {        display: flex;        align-items: center;        justify-content: center;        gap: 8px;        padding: 12px 0 18px;        color: #94a3b8;        font-size: 12px;      }      .rdg-search-loading.is-hidden {        display: none !important;      }      .rdg-search-loading .rdg-spinner {        width: 14px;        height: 14px;        border-radius: 999px;        border: 2px solid rgba(15, 23, 42, 0.15);        border-top-color: rgba(15, 23, 42, 0.55);        animation: rdg-spin 0.9s linear infinite;      }      @keyframes rdg-spin {        to {          transform: rotate(360deg);        }      }    
`

export const SEARCH_ISOLATE_SCRIPT = `
        (() => {          try {            const thresholdCount = 12;            const selectCards = (root) =>              Array.from(                (root || document).querySelectorAll(".bili-video-card__wrap")              );            const emit = (message) => {              if (!message) return;              console.log("rdg-debug:" + message);            };            const emitMaskReady = () => {              if (state.maskReady) return;              state.maskReady = true;              console.log("rdg-mask:ready");            };            const body = document.body;            const root = document.documentElement;            root.style.overflow = "hidden";            root.style.width = "100vw";            root.style.maxWidth = "100vw";            root.style.boxSizing = "border-box";            body.style.margin = "0";            body.style.padding = "0";            body.style.background = "#ffffff";            body.style.display = "flex";            body.style.flexDirection = "column";            body.style.height = "100%";            body.style.width = "100vw";            body.style.maxWidth = "100vw";            body.style.boxSizing = "border-box";            body.style.overflowX = "hidden";            Array.from(body.children).forEach((el) => {              if (                el.id === "rdg-search-list" ||                el.id === "rdg-search-loader"              ) {                return;              }              el.style.display = "none";            });            let list = document.getElementById("rdg-search-list");            if (!list) {              list = document.createElement("div");              list.id = "rdg-search-list";              body.appendChild(list);              emit("list:init");            }            list.style.display = "flex";            list.style.flexDirection = "column";            list.style.alignItems = "stretch";            list.style.gap = "12px";            list.style.padding = "12px 0";            list.style.width = "100vw";            list.style.maxWidth = "100vw";            list.style.minWidth = "0";            list.style.boxSizing = "border-box";            list.style.overflowX = "hidden";            list.style.overflow = "auto";            list.style.height = "100%";            list.style.position = "relative";            list.style.visibility = "visible";            list.style.opacity = "1";            let sentinel = document.getElementById("rdg-search-sentinel");            if (!sentinel) {              sentinel = document.createElement("div");              sentinel.id = "rdg-search-sentinel";              sentinel.style.width = "100%";              sentinel.style.height = "1px";              sentinel.style.pointerEvents = "none";              list.appendChild(sentinel);            }            let loader = document.getElementById("rdg-search-loading");            if (!loader) {              loader = document.createElement("div");              loader.id = "rdg-search-loading";              loader.className = "rdg-search-loading is-hidden";              loader.innerHTML =                '<span class="rdg-spinner"></span><span class="rdg-loading-text">鍔犺浇...</span>';              list.appendChild(loader);            }            const state = window.__rdgSearchState || {              loading: false,              pending: false,              page: 1,              done: false,              bootstrapped: false,              url: "",              lastLoadAt: 0,              loadDelayMs: 150,              retryMap: {},              maxRetries: 1,              retryDelayMs: 250,              skipOnEmpty: true,              emptyStreak: 0,              maxEmptyStreak: 3,              frameTimeoutMs: 4500            };            window.__rdgSearchState = state;            const currentUrl = window.location.href;            const isNewUrl = state.url !== currentUrl;            if (isNewUrl) {              state.loading = false;              state.pending = false;              state.page = 1;              state.done = false;              state.bootstrapped = false;              state.url = currentUrl;              state.logged = {};              state.retryMap = {};              state.loadDelayMs = 150;              state.emptyStreak = 0;              state.skipOnEmpty = true;              state.maxEmptyStreak = 3;              state.frameTimeoutMs = 4500;              state.maskReady = false;              if (state.observer) {                state.observer.disconnect();                state.observer = null;              }              list.innerHTML = "";              if (sentinel) {                list.appendChild(sentinel);              }              if (loader) {                list.appendChild(loader);              }            }            if (!Number.isFinite(state.loadDelayMs)) {              state.loadDelayMs = 150;            }            if (!Number.isFinite(state.frameTimeoutMs)) {              state.frameTimeoutMs = 4500;            }            if (state.bootstrapped) {              emitMaskReady();              return;            }            state.bootstrapped = true;            const seen = new Set();            const parseCardsFromDocument = (doc) => selectCards(doc);            const getBvid = (card) => {              const link =                card.querySelector("a[href*='BV']") || card.querySelector("a");              const url = link ? link.href : "";              if (!url) return "";              const match = url.match(/BV[0-9A-Za-z]{10}/);              return match ? match[0] : "";            };            const getOuterTag = (card) => {              const match = card.outerHTML.match(/^<[^>]+>/);              if (match) return match[0];              return "<" + card.tagName.toLowerCase() + ">";            };            const maybeLogFirstTag = (page, source, nodes) => {              if (!page || !nodes || !nodes.length) return;              if (!state.logged) state.logged = {};              const key = "tag:" + source + ":" + page;              if (state.logged[key]) return;              const tag = getOuterTag(nodes[0]);              emit("card:first " + source + " page=" + page + " tag=" + tag);              state.logged[key] = true;            };            const makeCard = (card) => {              card.style.setProperty("position", "relative", "important");              card.style.setProperty("left", "auto", "important");              card.style.setProperty("top", "auto", "important");              card.style.setProperty("right", "auto", "important");              card.style.setProperty("bottom", "auto", "important");              card.style.setProperty("transform", "none", "important");              card.style.setProperty("opacity", "1", "important");              card.style.setProperty("display", "block", "important");              const wrapper = document.createElement("div");              wrapper.className = "rdg-search-item";              wrapper.style.position = "relative";              wrapper.style.width = "100%";              wrapper.style.maxWidth = "100%";              wrapper.style.minWidth = "0";              wrapper.style.margin = "0";              wrapper.style.display = "block";              wrapper.style.flex = "0 0 auto";              wrapper.style.cursor = "pointer";              wrapper.style.overflow = "hidden";              wrapper.style.borderRadius = "14px";              wrapper.style.zoom = "0.9";              wrapper.style.transformOrigin = "top left";              card.style.setProperty("width", "100%", "important");              card.style.setProperty("max-width", "100%", "important");              card.style.setProperty("min-width", "0", "important");              card.style.setProperty("margin", "0", "important");              card.style.setProperty("box-sizing", "border-box", "important");              card.style.setProperty("overflow", "hidden", "important");              const overlay = document.createElement("div");              overlay.className = "rdg-search-card-mask";              overlay.style.position = "absolute";              overlay.style.inset = "0";              overlay.style.background = "transparent";              overlay.style.pointerEvents = "auto";              overlay.style.borderRadius = "inherit";              overlay.style.zIndex = "3";              const handleClick = (event) => {                if (event) {                  event.preventDefault();                  event.stopPropagation();                  event.stopImmediatePropagation?.();                }                const bvid = getBvid(card);                if (!bvid) return;                console.log("rdg-bvid:" + bvid);              };              overlay.addEventListener("click", handleClick, true);              wrapper.addEventListener("click", handleClick, true);              wrapper.addEventListener(                "pointerdown",                (event) => {                  event.preventDefault();                  event.stopPropagation();                  event.stopImmediatePropagation?.();                },                true              );              wrapper.appendChild(card);              wrapper.appendChild(overlay);              list.appendChild(wrapper);            };            const appendCards = (nodes, page, source) => {              const pageCards = Array.from(nodes || []);              if (!pageCards.length) return;              maybeLogFirstTag(page, source || "page", pageCards);              const beforeCount = list.children.length;              pageCards.forEach((card) => {                const bvid = getBvid(card);                if (bvid && seen.has(bvid)) return;                if (bvid) seen.add(bvid);                const clone = card.cloneNode(true);                makeCard(clone);              });              if (sentinel && sentinel.parentNode === list) {                list.appendChild(sentinel);              }              if (loader && loader.parentNode === list) {                list.appendChild(loader);              }              const afterCount = list.children.length;              if (afterCount !== beforeCount) {                emit("list:total=" + afterCount);              }              emitMaskReady();            };            const syncLoadingIndicator = () => {              if (!loader) return;              const shouldShow = state.loading || state.pending;              loader.classList.toggle("is-hidden", !shouldShow);            };            const getCurrentPage = () => {              try {                const url = new URL(window.location.href);                const page = Number(url.searchParams.get("page"));                return Number.isFinite(page) && page > 0 ? page : 1;              } catch {                return 1;              }            };            state.page = getCurrentPage();            const buildPageUrl = (page) => {              const url = new URL(window.location.href);              url.searchParams.set("page", String(page));              url.searchParams.set("search_source", "5");              return url.toString();            };            const loadPageFromFetch = async (page, url) => {              try {                const res = await fetch(url, { credentials: "include" });                if (!res.ok) {                  emit("loadPage:fetch-status page=" + page + " " + res.status);                  return [];                }                const html = await res.text();                const doc = new DOMParser().parseFromString(html, "text/html");                const cards = parseCardsFromDocument(doc);                if (!cards.length || page >= 2) {                  emit("loadPage:fetch page=" + page + " cards=" + cards.length);                }                return cards;              } catch (err) {                emit("loadPage:fetch-error page=" + page);                return [];              }            };            const getLoaderFrame = () => {              let frame = document.getElementById("rdg-search-loader");              if (!frame) {                frame = document.createElement("iframe");                frame.id = "rdg-search-loader";                frame.setAttribute("aria-hidden", "true");                frame.style.position = "fixed";                frame.style.left = "0";                frame.style.top = "0";                frame.style.width = "360px";                frame.style.height = "640px";                frame.style.border = "0";                frame.style.opacity = "0.01";                frame.style.pointerEvents = "none";                frame.style.display = "block";                frame.style.background = "transparent";                body.appendChild(frame);              } else {                frame.style.display = "block";                frame.style.opacity = "0.01";              }              return frame;            };            const loadPageViaFrame = (page, url) =>              new Promise((resolve) => {                let settled = false;                let attempts = 0;                const maxAttempts = 60;                let pollTimer = null;                let loggedMeta = false;                let observer = null;                const frame = getLoaderFrame();                const logFrameMeta = (doc) => {                  if (loggedMeta) return;                  loggedMeta = true;                  const title = doc?.title || "";                  const ready = doc?.readyState || "";                  emit(                    "loadPage:frame-meta page=" +                      page +                      " ready=" +                      ready +                      " title=" +                      title                  );                };                const getEmptyReason = (doc) => {                  if (!doc) return "";                  const title = doc.title || "";                  if (title.includes("verify") || title.includes("captcha")) {                    return "verify";                  }                  if (title.includes("璁块棶") || title.includes("鍙楅檺")) {                    return "access";                  }                  if (                    doc.querySelector(                      ".no-result, .search-no-result, .search-empty, .error-container, .search-error"                    )                  ) {                    return "empty";                  }                  const text = doc.body?.innerText || "";                  if (text.includes("no results") || text.includes("not found")) {                    return "empty";                  }                  return "";                };                const cleanup = (cards) => {                  if (settled) return;                  settled = true;                  frame.removeEventListener("load", handleLoad);                  clearTimeout(timeout);                  if (pollTimer) clearInterval(pollTimer);                  if (observer) observer.disconnect();                  emit("loadPage:frame page=" + page + " cards=" + cards.length);                  resolve(cards);                };                const handleLoad = () => {                  const attachObserver = (doc) => {                    if (!doc?.body || observer) return;                    observer = new MutationObserver(() => {                      const cards = selectCards(doc);                      if (cards.length) {                        cleanup(cards);                      }                    });                    observer.observe(doc.body, { childList: true, subtree: true });                  };                  pollTimer = setInterval(() => {                    attempts += 1;                    try {                      const doc = frame.contentDocument;                      const cards = doc ? selectCards(doc) : [];                      attachObserver(doc);                      if (cards.length) {                        cleanup(cards);                        return;                      }                      const reason = getEmptyReason(doc);                      if (reason) {                        logFrameMeta(doc);                        emit(                          "loadPage:frame-empty page=" +                            page +                            " reason=" +                            reason                        );                        cleanup([]);                        return;                      }                      if (attempts >= maxAttempts) {                        logFrameMeta(doc);                        cleanup([]);                      }                    } catch (err) {                      emit("loadPage:frame-error page=" + page);                      cleanup([]);                    }                  }, 200);                };                const timeout = setTimeout(() => {                  emit("loadPage:frame-timeout page=" + page);                  cleanup([]);                }, state.frameTimeoutMs);                frame.addEventListener("load", handleLoad);                frame.src = url;              });            const loadPage = async (page) => {              const url = buildPageUrl(page);              emit("loadPage:start page=" + page);              if (page === 2) emit("loadPage:url page=2 " + url);              let cards = await loadPageFromFetch(page, url);              if (!cards.length) {                emit("loadPage:fallback frame page=" + page);                cards = await loadPageViaFrame(page, url);              }              emit("loadPage:done page=" + page + " cards=" + cards.length);              return cards;            };            const queueNextPage = () => {              if (state.done) return;              if (state.loading) {                state.pending = true;                return;              }              const now = Date.now();              const waitMs = Math.max(                0,                state.lastLoadAt + state.loadDelayMs - now              );              state.loading = true;              state.pending = false;              syncLoadingIndicator();              const nextPage = state.page + 1;              emit("loadNextPage:start page=" + nextPage);              setTimeout(async () => {              const nextCards = await loadPage(nextPage);              state.lastLoadAt = Date.now();              if (!nextCards.length) {                if (state.skipOnEmpty) {                  state.emptyStreak += 1;                  state.page = nextPage;                  state.loading = false;                  syncLoadingIndicator();                  emit(                    "loadNextPage:skip page=" +                      nextPage +                      " streak=" +                      state.emptyStreak                  );                  if (state.emptyStreak >= state.maxEmptyStreak) {                    state.done = true;                    emit(                      "loadNextPage:empty-streak-stop streak=" +                        state.emptyStreak                    );                    return;                  }                  if (                    state.pending ||                    shouldLoadNext() ||                    list.scrollHeight <= list.clientHeight                  ) {                    queueNextPage();                  }                  return;                }                const retries = state.retryMap[nextPage] || 0;                if (retries < state.maxRetries) {                  state.retryMap[nextPage] = retries + 1;                  state.loadDelayMs = Math.min(                    state.loadDelayMs + 200,                    900                  );                  state.loading = false;                  syncLoadingIndicator();                  emit(                    "loadNextPage:retry page=" +                      nextPage +                      " attempt=" +                      state.retryMap[nextPage]                  );                  setTimeout(() => {                    queueNextPage();                  }, state.retryDelayMs);                  return;                }                state.done = true;                state.loading = false;                syncLoadingIndicator();                emit(                  "loadNextPage:empty page=" +                    nextPage +                    " retries=" +                    retries                );                return;              }              state.emptyStreak = 0;              delete state.retryMap[nextPage];              state.loadDelayMs = 200;              appendCards(nextCards, nextPage, "page");              state.page = nextPage;              state.loading = false;              syncLoadingIndicator();              emit(                "loadNextPage:done page=" +                  nextPage +                  " cards=" +                  nextCards.length              );                if (state.done) return;                if (                  state.pending ||                  shouldLoadNext() ||                  list.scrollHeight <= list.clientHeight                ) {                  queueNextPage();                }              }, waitMs);            };            const shouldLoadNext = () => {              const remainingPx =                list.scrollHeight - (list.scrollTop + list.clientHeight);              const thresholdPx = Math.max(list.clientHeight * 5, 1600);              return remainingPx <= thresholdPx;            };            let scrollRaf = null;            list.addEventListener("scroll", () => {              if (scrollRaf) return;              scrollRaf = requestAnimationFrame(() => {                scrollRaf = null;                if (shouldLoadNext()) queueNextPage();              });            });            if ("IntersectionObserver" in window && sentinel) {              state.observer = new IntersectionObserver(                (entries) => {                  if (entries.some((entry) => entry.isIntersecting)) {                    queueNextPage();                  }                },                { root: list, rootMargin: "2200px 0px", threshold: 0.01 }              );              state.observer.observe(sentinel);            }            const bootstrap = async () => {              emit("bootstrap:start page=" + state.page);              const initialDomCards = selectCards(document);              emit("bootstrap:domCards=" + initialDomCards.length);              if (initialDomCards.length) {                appendCards(initialDomCards, state.page, "dom");              }              const initialCards = await loadPage(state.page);              emit("bootstrap:pageCards=" + initialCards.length);              if (initialCards.length) {                appendCards(initialCards, state.page, "page");              }              emitMaskReady();              if (list.scrollHeight <= list.clientHeight) {                queueNextPage();              }            };            bootstrap();          } catch (err) {            const message = err && err.message ? err.message : String(err);            console.log("rdg-debug:script-error " + message);          }        })();      
`

export const buildSearchUrl = (query) => {
  const keyword = encodeURIComponent(String(query || "").trim());
  if (!keyword) return "https://search.bilibili.com/all";
  return `https://search.bilibili.com/all?keyword=${keyword}`;
};
